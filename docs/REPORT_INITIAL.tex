\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{tasks}
\usepackage{listings}
\usepackage[table]{xcolor}
\usepackage{hyperref}

\definecolor{javared}{rgb}{0.6, 0, 0}
\definecolor{javagreen}{rgb}{0.25, 0.5, 0.35}
\definecolor{javapurple}{rgb}{0.5, 0, 0.35}
\definecolor{javadocblue}{rgb}{0.25, 0.35, 0.75}
\definecolor{pythonblue}{rgb}{0, 0, 0.6}
\definecolor{pythonred}{rgb}{0.6, 0, 0}
\definecolor{pythongreen}{rgb}{0, 0.5, 0}
\definecolor{sqlgreen}{rgb}{0, 0.6, 0}
\definecolor{sqlgray}{rgb}{0.5, 0.5, 0.5}
\definecolor{sqlred}{rgb}{0.78, 0, 0.32}

\definecolor{tablegrey}{rgb}{0.9,0.9,0.9}
%\graphicspath{ {images/} }



\title{MeamDB}

\date{\today}

\author{MEAM Programming Team \\
Student 1 asr3571: Anthony Roberts\\
Student 2 mnc7702: Michael Clark\\
Student 3 mad1943: Makenzie Dorsey\\
Student 4 tts1848: Emi Simpson\\
}

\begin{document}

    \maketitle

    \section{Introduction}
    For this project, we would like to work with the Music Domain
    and our backup option will be the Recipes Domain. We plan to
    implement our project using Java.

    \vspace{0.5cm}

    \noindent Our database application will be run through the command line
    and will feature frequent user interaction in order to perform the desired
    commands from the user. We will design the application to be highly usable,
    provide user security, data integrity, and efficient access to the stored data.

    \section{Design}
    \subsection{Conceptual Model}

    \vspace{0.5cm}

%    \begin{figure}
%        \includegraphics[width=\linewidth]{ER-Diagram/MeamDB ER Diagram.png}
%    \end{figure}

    \begin{center}
    \includegraphics[width=5.5in]{ER-Diagram/MeamDB ER Diagram.png}
    \end{center}
    \caption{MeamDB ER Diagram showing entities and relationships}
    \label{ER Diagram}

    \vspace{0.5cm}

    \noindent For our ER diagram, we first decided to have five entity types:
    Artist, Song, Collection, Album, and User. We gave entity type User the attributes
    username, password, composite attribute name (first\_name, last\_name), email,
    last\_login, and creation\_date. The email and username will have the restriction that it must be unique
    for each user. The key for User will be a uid that is generated when a new user is
    created and it would allow users to update their name, email, and password without
    changing the key. The last\_login and creation\_date attributed will be populated by the program
    to track every user login and store when a new user account is first created. The derived attributes
    (number\_following, number\_followers, number\_collections) will be generated as the user
    follows other users, gains followers, and creates playlists of their own.

    \vspace{0.5cm}

    \noindent We gave the Artist the attributes name and the key artist\_id that
    will be generated when an artist is created. This would allow artists to change their
    name (like Prince) should they choose to or have any legal issues with their label. The
    name will have the restriction that it must be unique to the artist.

    \vspace{0.5cm}

    \noindent The Album entity type has the attributes name, release\_date, and derived attribute
    genre that will be based on the artist who made it. The key
    attribute will be an album\_id generated when an album is created. This allows albums
    with the same name to exist if they are made by different artists.

    \vspace{0.5cm}

    \noindent In our design, Song has title, length, genre, and release\_date. We will
    generate a sid to be the key attribute to allow us to distinguish between songs with
    the same name, length, artist and release\_date.

    \vspace{0.5cm}

    \noindent Each Collection has a name and key attribute cid. We will calculate
    the no\_songs and total\_length based on the songs that are placed in the collection.

    \subsection{Reduction to Tables}

    \begin{itemize}
        \item Album( \underline{album\_id}, name, release\_date )
        \item Artist( \underline{artist\_id}, name )
        \item Song( \underline{sid}, length, title, genre, release\_date )
        \item User( \underline{uid}, username, password, fname, lname, email, last\_login, creation\_date )
        \item Collection( \underline{cid}, name, \emph{uid} )
        \item Album\_Song( \emph{album\_id}, \emph{sid}, track\_number )
        \item Album\_Artist( \emph{album\_id}, \emph{artist\_id} )
        \item Song\_Artist( \emph{sid}, \emph{artist\_id} )
        \item Song\_Collection( \emph{sid}, \emph{cid} )
        \item Follower( \emph{follower}, \emph{followed} )
        \item Play( \emph{uid}, \emph{sid}, last\_time\_listened )
    \end{itemize}

    \vspace{0.5cm}

    \noindent We created separate tables (Album, Artist, Song, Collection, User) for each of our
    entities and used foreign keys to represent the relationships between the different entities.
    \begin{itemize}
        \item Album Entity Type: The relationship between the Album entity type and other entity types such as Song and Artist is represented by creating new tables like Album\_Song and Album\_Artist that have the album\_id key attribute as a foreign key. This allows the Song and Artist entities to be directly related to the Album.
        \item Artist Entity Type: The Artist entity type is related to the Song entity type through a new table Song\_Artist that utilizes the artist\_id as a foreign key similar to how the Artist is also related to the Album through the Album\_Artist table.
            \begin{itemize}
                \item Artists have an N:M relationship with albums. An artist can have 0 to many albums and an album must have at least 1 artist.
                \item Artists have an N:M relationship with songs. A song can be made by at least one artist and an artist can have 0 to many songs.

            \end{itemize}
                \item Song Entity Type: The Artist, Album, and Collection entities are related to the Song entity through the Album\_Song, Song\_Artist and Song\_Collection tables that all use the song\_id attribute to distinguish how they relate with the Song entity.
            \begin{itemize}
                \item Songs have an N:M relationship with collections. A song can be on 0 to many collections, and a collection must have at least one song.
                \item Songs have a N:M relationship with albums. A song can be on 1 or more albums, and an album must have at least one song. For this database, we are considering singles to be albums with one song, and albums can have multiple artists. The relationship has an attribute \“track\_no\” which will be used to keep track of the order of songs on an album.
            \end{itemize}
                \item Collection Entity Type: The relationship between the Collection entity type to the User entity is made by enforcing the user\_id attribute as a foreign key when creating a new Collection. Additionally, Song\_Collection is related to the Collection entity by using a collection\_id foreign key at the moment of creation.
        \item User Entity Type: The User is related to the Collection entity through their user\_id which will then keep track of all of their albums, songs, and artists in a created collection
            \begin{itemize}
                \item Users have a N:M relationship with collections. A user can make 0 to many collections, and a collection can be made by 1 to many users.
                \item The user has a N:M relationship with itself, called \“follows.\” Users can follow 0 to many other users or be followed by 0 to many users.
                \item Users will have an N:M relationship with songs, \“listens to.\” Users can listen to 0 to many songs and songs can be listened to by 0 to many users. The relationship has the attribute \“timestamp,\” which we will use to keep track of how often a user listens to a given song.
            \end{itemize}
    \end{itemize}
%
%
%
%
    \subsection{Data Requirements/Constraints}
    In the Follower relationship table, both of the foreign keys, follower and followed, reference the User's uid. These 2 uid fields cannot be the same because the User is not allowed to follow themselves.

    \vspace{0.5cm}

    \noindent All of the following attributes in our tables are required to be not null:

    \begin{itemize}
        \item Album Attributes
            \begin{tasks}[style=itemize, column-sep= 25mm, label-align=left, label-offset={2mm}, label-width={3mm}, item-indent={10mm}](4)
                \task[$-$] album\_id
                \task[$-$] name
                \task[$-$] release\_date
            \end{tasks}
        \item Album\_Artist Attributes
            \begin{tasks}[style=itemize, column-sep= 25mm, label-align=left, label-offset={2mm}, label-width={3mm}, item-indent={10mm}](4)
                \task[$-$] album\_id
                \task[$-$] artist\_id
            \end{tasks}
        \item Album\_Song Attributes
            \begin{tasks}[style=itemize, column-sep= 25mm, label-align=left, label-offset={2mm}, label-width={3mm}, item-indent={10mm}](4)
                \task[$-$] album\_id
                \task[$-$] sid
                \task[$-$] track\_number
            \end{tasks}
        \item Artist Attributes
            \begin{tasks}[style=itemize, column-sep= 25mm, label-align=left, label-offset={2mm}, label-width={3mm}, item-indent={10mm}](4)
                \task[$-$] artist\_id
                \task[$-$] name
            \end{tasks}
        \item Collection Attributes
            \begin{tasks}[style=itemize, column-sep= 25mm, label-align=left, label-offset={2mm}, label-width={3mm}, item-indent={10mm}](4)
                \task[$-$] cid
                \task[$-$] name
                \task[$-$] uid
            \end{tasks}
        \item Follower Attributes
            \begin{tasks}[style=itemize, column-sep= 25mm, label-align=left, label-offset={2mm}, label-width={3mm}, item-indent={10mm}](4)
                \task[$-$] follower
                \task[$-$] followed
            \end{tasks}
        \item Play Attributes
            \begin{tasks}[style=itemize, column-sep= 25mm, label-align=left, label-offset={2mm}, label-width={3mm}, item-indent={10mm}](4)
                \task[$-$] uid
                \task[$-$] sid
                \task[$-$] timestamp
            \end{tasks}
        \item Song Attributes
            \begin{tasks}[style=itemize, column-sep= 25mm, label-align=left, label-offset={2mm}, label-width={3mm}, item-indent={10mm}](4)
                \task[$-$] sid
                \task[$-$] length
                \task[$-$] title
                \task[$-$] genre
                \task[$-$] release\_date
            \end{tasks}
        \item Song\_Artist Attributes
            \begin{tasks}[style=itemize, column-sep= 25mm, label-align=left, label-offset={2mm}, label-width={3mm}, item-indent={10mm}](4)
                \task[$-$] sid
                \task[$-$] artist\_id
            \end{tasks}
        \item Song\_Collection Attributes
            \begin{tasks}[style=itemize, column-sep= 25mm, label-align=left, label-offset={2mm}, label-width={3mm}, item-indent={10mm}](4)
                \task[$-$] sid
                \task[$-$] cid
            \end{tasks}
        \item User Attributes
            \begin{tasks}[style=itemize, column-sep= 25mm, label-align=left, label-offset={2mm}, label-width={3mm}, item-indent={10mm}](4)
                \task[$-$] uid
                \task[$-$] username
                \task[$-$] password
                \task[$-$] fname
                \task[$-$] lname
                \task[$-$] email
                \task[$-$] last\_login
                \task[$-$] creation\_date
            \end{tasks}
    \end{itemize}

    \subsection{Sample Instance Data}

    \begin{center}
        \begin{tabular}{ |c|c|c| }
            \hline
            \rowcolor{tablegrey} \multicolumn{3}{|c|}{Album} \\
            \hline
            \underline{album\_id} &name &release\_date \\
            \hline
            0 & Young, Wild \& Free (feat. Bruno Mars) & 2011-10-11 \\
            \hline
            1 & Asaph's Arrows & 2012-02-28 \\
            \hline
            2 & 2002 & 2018-04-19 \\
            \hline
            3 & Final Straw & 2004-01-01 \\
            \hline
            4 & How It Works & 2001-08-13 \\
            \hline
        \end{tabular}
    \end{center}



    \begin{center}
        \begin{tabular}{ |c|c|c| }
            \hline
            \rowcolor{tablegrey} \multicolumn{2}{|c|}{Artist} \\
            \hline
            \underline{artist\_id} &name \\
            \hline
            0 & The Destination \\
            \hline
            1 & Coolio \\
            \hline
            2 & G Herbo \\
            \hline
            3 & Ti\"{e}sto \\
            \hline
            4 & Hot Chocolate \\
            \hline
        \end{tabular}
    \end{center}



    \begin{center}
        \begin{tabular}{ |c|c|c|c|c| }
            \hline
            \rowcolor{tablegrey} \multicolumn{5}{|c|}{Song} \\
            \hline
            \underline{sid} & length & title & genre & release\_date \\
            \hline
            0 & 153 & For What It's Worth & British soundtrack & 1966-12-05 \\
            \hline
            1 & 326 & Comedown & Alternative emo & 1994-12-06 \\
            \hline
            2 & 328 & Blacken the Cursed Sun & Alternative metal & 2006-08-21 \\
            \hline
            3 & 256 & Machinehead & New romantic & 1994-12-06 \\
            \hline
            4 & 266 & Glycerine & Adult standards & 1994-12-06 \\
            \hline
        \end{tabular}
    \end{center}




    \scriptsize
    % change text to script size for table sizing
    \begin{center}
        \begin{tabular}{ |c|c|c|c|c|c|c|c| }
            \hline
            \rowcolor{tablegrey} \multicolumn{8}{|c|}{User} \\
            \hline
            \underline{uid} & username & password & fname & lname & email & last\_login & creation\_date \\
            \hline
            1 & UserFolk & 123456 & John & Doe & jdoe@gmail.com & 2022-02-18 & 2022-02-18\\
            \hline
            2 & BobbyS & password123 & Bob & Smith & bsmith@aol.com & 2022-02-16 & 2022-01-01 \\
            \hline
        \end{tabular}
    \end{center}
    % change text to normal for the rest of the document
    \normalsize



    \begin{center}
        \begin{tabular}{ |c|c|c| }
            \hline
            \rowcolor{tablegrey} \multicolumn{3}{|c|}{Collection} \\
            \hline
            \underline{cid} & name & \emph{uid} \\
            \hline
            1 & Bangers & 1 \\
            \hline
            2 & Sad Hours & 1 \\
            \hline
            3 & Super Sad Boi Hours & 2 \\
            \hline
            4 & Angry Super Bowl Music & 2 \\
            \hline
            5 & Bath Time Breather & 4 \\
            \hline
        \end{tabular}
    \end{center}



    \begin{center}
        \begin{tabular}{ |c|c|c| }
            \hline
            \rowcolor{tablegrey} \multicolumn{3}{|c|}{Album\_Song} \\
            \hline
            \emph{album\_id} & \emph{sid} & track\_number \\
            \hline
            7814 & 0 & 1 \\
            \hline
            1169 & 1 & 5 \\
            \hline
            8208 & 2 & 7 \\
            \hline
            1169 & 3 & 7 \\
            \hline
            1169 & 4 & 10 \\
            \hline
        \end{tabular}
    \end{center}



    \begin{center}
        \begin{tabular}{ |c|c| }
            \hline
            \rowcolor{tablegrey} \multicolumn{2}{|c|}{Album\_Artist} \\
            \hline
            \emph{album\_id} & \emph{ artist\_id } \\
            \hline
            0 & 1902 \\
            \hline
            1 & 505 \\
            \hline
            2 & 3141 \\
            \hline
            3 & 3672 \\
            \hline
            4 & 634 \\
            \hline
        \end{tabular}
    \end{center}



    \begin{center}
        \begin{tabular}{ |c|c| }
            \hline
            \rowcolor{tablegrey} \multicolumn{2}{|c|}{Song\_Artist} \\
            \hline
            \emph{sid} & \emph{artist\_id} \\
            \hline
            0 & 4019 \\
            \hline
            1 & 3431 \\
            \hline
            2 & 3004 \\
            \hline
            3 & 3431 \\
            \hline
            4 & 3431 \\
            \hline
        \end{tabular}
    \end{center}



    \begin{center}
        \begin{tabular}{ |c|c| }
            \hline
            \rowcolor{tablegrey} \multicolumn{2}{|c|}{Song\_Collection} \\
            \hline
            \emph{sid} & \emph{cid} \\
            \hline
            13368 & 12 \\
            \hline
            2161 & 13 \\
            \hline
            11339 & 13 \\
            \hline
            3703 & 13 \\
            \hline
            10558 & 13 \\
            \hline
        \end{tabular}
    \end{center}



    \begin{center}
        \begin{tabular}{ |c|c| }
            \hline
            \rowcolor{tablegrey} \multicolumn{2}{|c|}{Follower} \\
            \hline
            \emph{Follower} & \emph{Followed} \\
            \hline
            1 & 2 \\
            \hline
            7 & 6 \\
            \hline
        \end{tabular}
    \end{center}



    \begin{center}
        \begin{tabular}{ |c|c|c| }
            \hline
            \rowcolor{tablegrey} \multicolumn{3}{|c|}{Play} \\
            \hline
            \emph{uid} & \emph{sid} & timestamp \\
            \hline
            6 & 1712 & 2020-03-20 10:43:30.302306 \\
            \hline
            6 & 2161 & 2020-02-29 10:56:54.644090 \\
            \hline
            7 & 2133 & 2020-02-29 03:05:01.205123 \\
            \hline
            7 & 2134 & 2020-02-18 13:02:00.345236 \\
            \hline
            7 & 754 & 2020-02-18 13:04:12.102078 \\
            \hline
        \end{tabular}
    \end{center}



    \section{Implementation}

    \subsection{Database Population}
    Our dataset was initially populated with over 13,000 songs directly from various Spotify playlists
    via the export to CSV feature on the \underline{\href{https://skiley.net/}{Skiley}} website.
    Our data was then accumulated together and cleaned to ensure every song has a single artist, no song
    is without a genre, the release date has the proper yyyy-mm-dd format and all special characters
    in the song titles or artist names (eg. \'{a}, \"{i}, \~{n}, etc.) were properly represented.

    \vspace{0.5cm}

    \noindent Additional data was later populated into our database via the Last.fm feature called
    \underline{\href{https://www.last.fm/about/trackmymusic}{Track My Music}}. This data was
    then parsed through to only upload any songs, albums, or artists from our personal Spotify
    listening or another Last.fm user's profile that is not currently present in our database.


    \subsubsection{Sample Create Statements}

    \lstset{
    frame=tb,
    language=SQL,
    aboveskip=3mm,
    belowskip=3mm,
    showstringspaces=false,
    columns=flexible,
    basicstyle=\ttfamily,
    numbers=none,
    numberstyle=\tiny\color{sqlgray},
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{sqlgreen},
    stringstyle=\color{sqlred},
    breaklines=true,
    breakatwhitespace=true,
    tabsize=4
    }

    \begin{lstlisting}
    CREATE TABLE song (
        sid integer not null primary key,
        length integer not null,
        title varchar(255) not null,
        genre varchar(127) not null,
        release_date date not null
    );

    CREATE TABLE user (
        uid integer default
            nextval('p320_12.userids'::regclass)
            not null primary key,
        username varchar(127) not null
            constraint unique_username unique,
        password varchar(127) not null,
        fname varchar(127) not null,
        lname varchar(127) not null,
        email varchar(127) not null
            constraint unique_email unique,
        last_login timestamp defualt CURRENT_TIMESTAMP
        creation_date timestamp defualt CURRENT_TIMESTAMP
    );
    \end{lstlisting}
    The initial data we acquired was uploaded into our database with a python script that parsed through
    our collated dataset.csv file. It uses data classes, tuples, and lists to separate each
    table's representative data and import it into our database.

    \lstset{
    frame=tb,
    language=Python,
    aboveskip=3mm,
    belowskip=3mm,
    showstringspaces=false,
    columns=flexible,
    basicstyle=\ttfamily,
    numbers=none,
    numberstyle=\tiny\color{gray},
    keywordstyle=\color{pythonblue}\bfseries,
    commentstyle=\color{gray},
    emphstyle=\ttb\color{pythonred},
    stringstyle=\color{pythongreen},
    breaklines=true,
    breakatwhitespace=true,
    tabsize=4
    }
    \begin{lstlisting}
    artist_values = [(aid, artist.name) for artist, aid in artist_ids.items()]
    album_values = [(aid, album.name, album.date) for album, aid in album_ids.items()]
    track_values = [(tid, track.duration, track.title, track.genre, track.date) for track, tid in track_ids.items()]
    song_artist_values = [(tid, artist_ids[track.artist]) for track, tid in track_ids.items()]
    album_artist_values = [(aid, artist_ids[album.artist]) for album, aid in album_ids.items()]
    album_song_values = [(album_ids[track.album], tid, track.track) for track, tid in track_ids.items()]

    def insert_many_statement(table: str, fields: List[str], n_records: int) -> sql.Composed:
        fields_sql = sql.SQL(',').join(
            map(sql.Identifier, fields)
        )
        single_value =  (
            sql.SQL('(') +
            sql.SQL(',').join(
                [sql.Placeholder()] * len(fields)
            ) +
            sql.SQL(')')
        )
        all_values = sql.SQL(',').join([single_value] * n_records)
        return sql.SQL('INSERT INTO {} ({}) VALUES {}').format(
            relation_prefix + sql.Identifier(table),
            fields_sql,
            all_values,
        )
    \end{lstlisting}

    \lstset{
    frame=tb,
    language=Java,
    aboveskip=3mm,
    belowskip=3mm, The temportary
    showstringspaces=false,
    columns=flexible,
    basicstyle=\ttfamily,
    numbers=none,
    numberstyle=\tiny\color{gray},
    keywordstyle=\color{javapurple}\bfseries,
    commentstyle=\color{javagreen},
    stringstyle=\color{javared},
    breaklines=true,
    breakatwhitespace=true,
    tabsize=4
    }

    \noindent The additional data we uploaded via Last.fm into our database was inserted
    by preparing and executing SQl statements in Java. Temporary tables
    were created to obtain the required data from the Last.fm connection and safely
    insert it into our preexisting tables.

    \begin{lstlisting}
    c.prepareStatement(
        "CREATE TEMPORARY TABLE IF NOT EXISTS "     +
        "found_album_info (" +
            "artist    TEXT,"                       +
            "mbid      CHAR(36),"                   +
            "albumName TEXT,"                       +
            "trackNum  INTEGER,"                    +
            "length    INTEGER,"                    +
            "trackName TEXT,"                       +
            "genre     TEXT,"                       +
            "release   DATE"                        +
        ") ON COMMIT DELETE ROWS;"
    ).execute();

    \end{lstlisting}

    \noindent Additional temporary tables are created (\lstinline{new_song_ids},
    \lstinline{new_album_ids}) to sequence the next available
    primary key for insertion to the artist, album and song entity
    tables. Following the insertion into these three tables, more SQL
    statements are used to insert the appropriate data into our relationship
    tables to directly relate the entity types to one another.

    \begin{lstlisting}

    c.prepareStatement(
        "INSERT INTO p320_12.artist (name)  " +
        "  SELECT artist                    " +
        "  FROM found_album_info            " +
        "  ON CONFLICT DO NOTHING           "
    ).execute();

    c.prepareStatement(
        "INSERT INTO p320_12.album "           +
        "SELECT DISTINCT ON (mbid) "           +
            "album_id, albumName, release "    +
        "FROM new_album_ids "                  +
        "JOIN found_album_info USING (mbid)"
    ).execute();

    c.prepareStatement(
        "INSERT INTO p320_12.song "                          +
            "SELECT sid, length, trackName, genre, release " +
            "FROM new_song_ids "                             +
            "JOIN found_album_info USING (mbid, trackNum)"
    ).execute();
    \end{lstlisting}

    
    \subsubsection{Sample Insert Statements}
    \lstset{
    frame=tb,
    language=SQL,
    aboveskip=3mm,
    belowskip=3mm,
    showstringspaces=false,
    columns=flexible,
    basicstyle=\ttfamily,
    numbers=none,
    numberstyle=\tiny\color{sqlgray},
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{sqlgreen},
    stringstyle=\color{sqlred},
    breaklines=true,
    breakatwhitespace=true,
    tabsize=4
    }
    \begin{lstlisting}
    INSERT INTO p320_12.song(
        sid, length, title, genre, release_date
    ) VALUES (
        66, 229, 'Love Somebody',
        'Alternative r&b', 2012-01-01
    )

    INSERT INTO p320_12.artist(artist_id, name)
    VALUES (51, 'Black Eyed Peas')

    INSERT INTO p320_12.album(album_id, name, release_date)
    VALUE (28, 'Pretty. Odd.', 2018-03-21)

    \end{lstlisting}
    All of the entity tables except User and Collection have already
    been assigned unique entity IDs before they were populated into
    the database. With the User and Collection entities, we altered the
    tables to include a serial primary key for the ID through a sequence
    to allow the unique ID attributes to auto increment upon insertion
    into the respective tables.
    \begin{lstlisting}
    create sequence userids;
    create sequence collection_ids
    \end{lstlisting}
    Due to the sequences, the below insert statements do not need to specify
    a uid or cid attributes because those fields will be auto incrementing
    to the next ID value whenever new data is entered into the table.
    \begin{lstlisting}
    INSERT INTO p320_12.user (
        username, password, fname, lname,
        email, last_login, creation_date
    ) VALUES (
        'LilBob', 'burger123', 'Gene', 'Belcher',
        'genebelcher@gmail.com', CURRENT_TIMESTAMP,
        CURRENT_TIMESTAMP
    )

    INSERT INTO p320_12.collection (name, uid)
    VALUES ('Sing My Heart Out', 7)
    \end{lstlisting}

    \subsection{Java Implementation}
    Our database implementation is based around obtaining user input to
    perform actions that query or alter the data within our database. Upon program
    execution, the user is presented with 3 options: login, create new account, or help.
    Below are examples of SQL statements used to alter our database should the user
    decide to login or create a new account.
    \lstset{
        frame=tb,
        language=Java,
        aboveskip=3mm,
        belowskip=3mm,
        showstringspaces=false,
        columns=flexible,
        basicstyle=\ttfamily,
        numbers=none,
        numberstyle=\tiny\color{gray},
        keywordstyle=\color{javapurple}\bfseries,
        commentstyle=\color{javagreen},
        stringstyle=\color{javared},
        breaklines=true,
        breakatwhitespace=true,
        tabsize=4
    }
    \begin{lstlisting}
    /** User Login **/
    PreparedStatement stmt = conn.prepareStatement(
            "UPDATE p320_12.user AS usr                   " +
            "SET last_login = CURRENT_TIMESTAMP           " +
            "FROM p320_12.user AS original                " +
            "WHERE usr.username = ? AND usr.password = ?  " +
            "AND original.uid = usr.uid                   " +
            "RETURNING usr.uid, original.last_login       "
    );
    \end{lstlisting}
    If the ResultSet of the query does not produce an error, it is a valid login.
    If there is an error, the user will be prompted to enter their credentials again
    in case of a mistype or spelling error.
    \\~\\
    During the process of creating an account, the entered username and email are
    subject to verification to ensure both inputs are unique to every user.
    \begin{lstlisting}
    /** User Username Verification **/
    String username = scan.nextLine();
    Statement stmt = conn.createStatement();
    ResultSet rs = stmt.executeQuery(
        "select * from p320_12.user"
    );
    while( rs.next() ) {
        if ( rs.getString("username").equals(username) )
            System.out.println(
                "That username is already in use."
            );
    }

    /** User Email Verification **/
    String email = scan.nextLine();
    Statement stmt = conn.createStatement();
    ResultSet rs = stmt.executeQuery(
        "select * from p320_12.user"
    );
    while( rs.next() ) {
        if ( rs.getString("email").equals(username) )
            System.out.println(
                "That email is already in use."
            );
    }

    /** User Account Creation **/
    PreparedStatement creationStatement = c.prepareStatement(
            "INSERT INTO p320_12.user (" +
                "username, password, fname," +
                "lname, email) " +
            "VALUES (?, ?, ?, ?, ?)" +
            "RETURNING uid"
    );

    creationStatement.setString(1, username);
    creationStatement.setString(2, password);
    creationStatement.setString(3, fname);
    creationStatement.setString(4, lname);
    creationStatement.setString(5, email);

    ResultSet rs = creationStatement.executeQuery();
    \end{lstlisting}
    As shown through the username and email verification snippets,
    the user information is checked for uniqueness before the data
    is entered into our database. Due to the requirements we have
    specified for our database, both the username and email must be
    unique. Once all the required input is collected from the user,
    the parameters are entered into the creationStatement variable and
    executed.
    \\~\\
    As the user continues to enter new inputs that call for searching
    through the database, the SearchKind, SortKind, and SortOrder enums
    are used to store user decisions before executing the query.
    \begin{lstlisting}
    private static enum SearchKind {Song, Artist, Album, Genre}
    private static enum SortKind {Song, Artist, Genre, Release}
    private static enum SortOrder {Asc, Desc}
    \end{lstlisting}
    One of the capabilities of our program is creating a new collection.
    This is done by prompting the user for a name for the new collection
    and ensuring the user does not already have a collection with the same
    name.
    \begin{lstlisting}
    String collectionName = scan.nextLine();

    Statement stmt = conn.createStatement();
    ResultSet rs = stmt.executeQuery(
        "select * from p320_12.collection " +
        "where p320_12.collection.uid = " + uid
    );
    while( rs.next() ) {
        if ( rs.getString("name").equals(collectionName) ) {
            System.out.println(
                "There already exists a collection " +
                "with that name"
            );
        }
    }
    \end{lstlisting}
    Once the collection name is determined to not be repeated, a new collection
    is created with the provided name and populated into the database.
    \begin{lstlisting}
    stmt.executeUpdate(
        "insert into p320_12.collection (name, uid) " +
        "values ('" + collectionName + "', " + uid + ")"
    );
    System.out.println(
        "Collection: " + collectionName +
        " has been created"
    );
    \end{lstlisting}
    To make sure all the actions are done on the correct user's account, their
    user id is stored and passed through every action method as they continue to perform
    actions that alter or modify the data in any way.



    \section{Data Analysis}

    
    
    
    \subsection{Hypothesis}
    Use this section to state the objectives of your data analysis; what are the observations you are expecting to find. Note that your final
    observations may end up differing from your proposal, that is also a valid result.
    \subsection{Data Preprocessing}
    Use this section to describe the preprocessing steps you have performed to prepare the data for the analytics. Preprocessing steps may include: data cleaning (e.g., filling missing values, fixing outliers), formatting the data (e.g., resolving issues like inconsistent abbreviations, multiples date format in the data), combining or splitting fields, add new information (data enrichness).

    Explain how the data was extracted from the database for the analysis; if you used complex queries or views, or both.
    \subsection{Data Analytics \& Visualization}
    Use this section to explain the process/techniques used to analyze the data, use data visualization to present the results, and explain them.
    \subsection{Conclusions}
    Use this section to explain the conclusions drawn from your data analysis.\\
    \section{Lessons Learned}
    Use this section to describe the issues you faced during the project and how you overcame them. Also, describe what you learned during this effort; this section, like the others, plays a critical component in determining your final grade.\\


    \section{Resources}
    Include in this section the resources you have used in your project beyond the normal code development
    such as data sets or data analytic tools (i.e. Weka, R).

    \subsection{Skiley}
    Skiley is a web app that integrates with Spotify to allow users to view their listening history,
    create playlists based on recommendations, and export public or private playlists on the user's profile.
    We used Skiley as our first avenue to create an initial dataset that will be populated to our database.
    Using the playlist export feature, we collated CSV files with a song's track name, artist name, album name,
    track duration, track number, artist genre, and album release date.

    \subsection{Last.fm}
    We used last.fm to populate more data into our database during implementation
    in order to have a larger data set for analyzation. We linked Last.fm to our
    personal spotify accounts so we could get the data about our song's play info
    (how many times have we played the song). From there, we implemented a feature
    that will allow Last.fm connection to our database to upload new music and fill
    a song's plays from Last.fm itself. Additionally, due to plays being publicly
    available on Last.fm, we were able to populate the database with song plays from
    long established users on Last.fm to allow for further analysis.

    \subsection{Excel}
    \subsubsection{Data Cleaning}
    After our initial data gathering from Skiley, the data was cleaned in Excel to ensure
    the following:
    \begin{enumerate}
        \item All songs have 1 genre
        \item Track duration is converted from minutes and seconds to total seconds
        \item Release date converted to the yyyy-mm-dd format
        \item All special letter characters are represented correctly
            \begin{itemize}
                \item eg. \'{a}, \"{o}, \~{n}, etc.
            \end{itemize}
    \end{enumerate}
    From collation, the data was split into 3 initial Excel sheets that contained the entities Song,
    Artist, and Album as detailed in our MeamDB ER Diagram. Using Excel's Power Query Editor, unique
    ids were created for every Song, Artist, and Album and queries were combined to match the relationships
    for AlbumSong, AlbumArtist, and SongArtist via their unique ids.

    \subsubsection{Data Visualization}
    After populating our database through our Java implementation, we downloaded our data as CSVs to
    analysize and make predictions. Excel was used to create graphs and charts to visualize our
    collections of data and draw conclusions from the results.

    \section{Appendix}
    %\appendix

    \subsection{SQL Statements}
    This section includes all the SQL statements that were written during Phase 4 of
    implementation.
    
    \subsubsection{SQL Indexes}

    Due to our Play table being the largest, most queried table in
    our database and its heavy use in providing analytics for users,
    three indexes were created on our Play table to
    provide faster access to the data upon query execution.

    \lstset{
    frame=tb,
    language=SQL,
    aboveskip=3mm,
    belowskip=3mm,
    showstringspaces=false,
    columns=flexible,
    basicstyle=\ttfamily,
    numbers=none,
    numberstyle=\tiny\color{sqlgray},
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{sqlgreen},
    stringstyle=\color{sqlred},
    breaklines=true,
    breakatwhitespace=true,
    tabsize=4
    }

    \begin{lstlisting}
    -- Simple hash index on sid used for generating top charts
    CREATE INDEX ON p320_12.play (sid);

    -- BTREE index on uid and timestamp created to order the
    -- listing of plays by user
    CREATE INDEX ON p320_12.play USING BTREE (uid, timestamp);

    -- BTREE index on timestamp to hasten the selection of
    -- plays within a certain time range when no user id can
    -- be specified
    CREATE INDEX ON p320_12.play USING BTREE (timestamp);
    \end{lstlisting}

    \noindent Despite not having a surplus of users being entered into our database,
    two indexes were created to make searching for a user to follow much quicker.
    With the uniqueness requirement of a user's email and username, both attributes
    can be used within the application to search for another user.
    \begin{lstlisting}
    CREATE INDEX ON p320_12.user (email);
    CREATE INDEX ON p320_12.user (username);
    \end{lstlisting}

    \noindent Finally, indexes were created for all of our relationship tables.
    Indexing on some of the foreign keys within these relationship tables
    helps speed up the process to search through the tables for song, artist,
    or album relationships that match the criteria parameters specified.
    \begin{lstlisting}
    CREATE INDEX ON p320_12.album_artist (album_id);
    CREATE INDEX ON p320_12.album_artist (artist_id);
    CREATE INDEX ON p320_12.album_song (sid);
    CREATE INDEX ON p320_12.album_song (album_id);
    CREATE INDEX ON p320_12.song_artist (sid);
    CREATE INDEX ON p320_12.song_collection (cid);
    \end{lstlisting}



    \subsubsection{Selecting the top 10 artists for a user}
    \lstset{
    frame=tb,
    language=Java,
    aboveskip=3mm,
    belowskip=3mm,
    showstringspaces=false,
    columns=flexible,
    basicstyle=\ttfamily,
    numbers=none,
    numberstyle=\tiny\color{gray},
    keywordstyle=\color{javapurple}\bfseries,
    commentstyle=\color{javagreen},
    stringstyle=\color{javared},
    breaklines=true,
    breakatwhitespace=true,
    tabsize=4
    }
    \begin{lstlisting}
    //select user's top 10 artists
    Statement stmt = conn.createStatement();
    ResultSet rs = stmt.executeQuery(
        "select distinct s.artist_id, count(s.artist_id) as total, a.name " +
        "from p320_12.play p, p320_12.song_artist s, p320_12.artist a " +
        "where p.sid = s.sid and p.uid = " + uid + " and a.artist_id = s.artist_id " +
        "group by s.artist_id, a.name " +
        "order by total desc " +
        "limit 10"
    );
    System.out.println("Artist Name | Total Artist Plays");
    while( rs.next() ){
        System.out.println(rs.getString("name") + " | " + rs.getInt("total"));
    }
    \end{lstlisting}

    \subsubsection{Retrieving the count of how many people follow and are followed by a user}

    \begin{lstlisting}
    //getting the amount of people the user follows
    Statement stmt = conn.createStatement();
    ResultSet rs = stmt.executeQuery(
        "select count(f) as fol from p320_12.follower f " +
        "where f.follower = '"+uid+"'"
    );
    if( rs.next() ){
        followers = rs.getInt("fol");
    }

    //getting the amount of people followed by the user
    Statement stmt = conn.createStatement();
    ResultSet rs = stmt.executeQuery(
        "select count(f) as fol from p320_12.follower f " +
        "where f.followed = '"+uid+"'"
    );
    if( rs.next() ){
        followed = rs.getInt("fol");
    }
    \end{lstlisting}

    \subsubsection{A minor edit to the view collections function to get the amount of collections of a user}

    \begin{lstlisting}
    Statement stmt3 = conn.createStatement();
    ResultSet total = stmt3.executeQuery(
        "select count(cid) as total from p320_12.collection " +
        "where p320_12.collection.uid = " + uid
    );

    if( total.next() && printing ) {
        System.out.println("Total collections: " + total.getInt("total"));
    }
    \end{lstlisting}

   \subsubsection{Recommending a user's 5 most popular genres of the month}

    \begin{lstlisting}
    PreparedStatement stmt = c.prepareStatement(
        "SELECT genre " +
        "FROM p320_12.play " +
        "JOIN p320_12.song USING (sid) " +
        "WHERE age(timestamp) < INTERVAL '1 month' " +
        "GROUP BY genre " +
        "ORDER BY COUNT(*) DESC " +
        "LIMIT 5;"
    );
    ResultSet rs = stmt.executeQuery();
    \end{lstlisting}


    \subsubsection{Recommending 50 most popular songs of the month, 50 most popular songs among a friend, 50 most popular among a genre, and 50 most popular songs for a user}

    \vspace{0.5cm}
    In the below statements, the question marks are replaced by user inputs that are collected
    before the SQL is called to query the database.

    \begin{lstlisting}
    switch(this) {
        case Month:
            // No args
            return
                "SELECT sid, title " +
                "FROM p320_12.play " +
                "JOIN p320_12.song USING (sid) " +
                "WHERE timestamp > CURRENT_TIMESTAMP - INTERVAL '1 month' " +
                "GROUP BY sid, title " +
                "ORDER BY COUNT(*) DESC " +
                "LIMIT 50;";
        case Friends:
            // 1 arg: uid
            return
                "SELECT sid, title " +
                "FROM p320_12.follower "+
                "JOIN p320_12.play "+
                    "ON play.uid = followed " +
                "JOIN p320_12.song " +
                    "USING (sid) " +
                "WHERE follower = ? " +
                    "AND age(timestamp) < INTERVAL '1 month' " +
                "GROUP BY sid, title " +
                "ORDER BY COUNT(*) DESC " +
                "LIMIT 50;";
        case Genres:
            // 1 arg: genre
            return
                "SELECT sid, title " +
                "FROM p320_12.play " +
                "JOIN p320_12.song " +
                    "USING (sid) " +
                "WHERE genre = ? " +
                    "AND age(timestamp) < interval '1 month' " +
                "GROUP BY sid, title " +
                "ORDER BY COUNT(*) DESC " +
                "LIMIT 50;";
        case Personal:
            // 1 arg: uid
            return
                "SELECT sid, title " +
                "FROM p320_12.recommendations(?) " +
                "JOIN p320_12.song " +
                    "USING (sid) " +
                "LIMIT 50;";
    }
    \end{lstlisting}

    \subsubsection{Display a recommended song's info}

    \begin{lstlisting}
    PreparedStatement stmt = c.prepareStatement(
        "SELECT title, length, genre, track_number, album.name, artist.name, mbid " +
        "FROM p320_12.song " +
        "JOIN p320_12.album_song USING (sid) " +
        "JOIN p320_12.album USING (album_id) " +
        "LEFT JOIN p320_12.song_artist USING (sid) " +
        "LEFT JOIN p320_12.artist USING (artist_id) " +
        "LEFT JOIN p320_12.album_mbid USING (album_id) " +
        "WHERE sid = ?;"
    );
    stmt.setInt(1, this.selectedSong);
    ResultSet result = stmt.executeQuery();
    \end{lstlisting}


    \subsubsection{Play a recommended song}

    \begin{lstlisting}
    PreparedStatement stmt = c.prepareStatement(
        "INSERT INTO p320_12.play VALUES (?, ?, CURRENT_TIMESTAMP);"
    );
    stmt.setInt(1, this.uid);
    stmt.setInt(2, this.selectedSong);
    stmt.execute();
    \end{lstlisting}




\end{document}
